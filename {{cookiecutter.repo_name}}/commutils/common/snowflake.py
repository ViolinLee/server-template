""" 生成18个数字组成的整数ID

改造自: https://github.com/junchen1992/py-snowflake
注意:装饰器@dataclass在python3.7引入,若使用SnowflakeID类请确保版本兼容
    在多线程和多进程下可能出现重复,可借助分布式锁(如Redis锁)实现并行环境下的ID唯一
"""

from dataclasses import dataclass
from datetime import datetime, timedelta, tzinfo
from time import time
from typing import Optional

__all__ = ('SnowflakeID', 'SnowflakeGenerator')

# Start timestamp (将影响生成位数)
START_TS = int(datetime(2023, 1, 1, 0, 0, 0).timestamp() * 1000)

# 41 bits timestamp maximum
MAX_TS = 0b11111111111111111111111111111111111111111

# 10 bits instance ID maximum
MAX_INSTANCE = 0b1111111111

# 12 bits sequence number maximum
MAX_SEQ = 0b111111111111


@dataclass(frozen=True)
class SnowflakeID:
    timestamp: int
    instance: int
    seq: int = 0

    def __post_init__(self):
        if self.timestamp < 0 or self.timestamp > MAX_TS:
            raise ValueError(f"timestamp must not be negative and must be less than {MAX_TS}!")

        if self.instance < 0 or self.instance > MAX_INSTANCE:
            raise ValueError(f"instance must not be negative and must be less than {MAX_INSTANCE}!")

        if self.seq < 0 or self.seq > MAX_SEQ:
            raise ValueError(f"seq must not be negative and must be less than {MAX_SEQ}!")

    @classmethod
    def parse(cls, snowflake: int) -> 'SnowflakeID':
        return cls(
            timestamp=snowflake >> 22,
            instance=snowflake >> 12 & MAX_INSTANCE,
            seq=snowflake & MAX_SEQ
        )

    @property
    def milliseconds(self) -> int:
        return self.timestamp + START_TS

    @property
    def seconds(self) -> float:
        return self.milliseconds / 1000

    @property
    def datetime(self) -> datetime:
        return datetime.utcfromtimestamp(self.seconds)

    def datetime_tz(self, tz: Optional[tzinfo] = None) -> datetime:
        return datetime.fromtimestamp(self.seconds, tz=tz)

    @property
    def timedelta(self) -> timedelta:
        return timedelta(milliseconds=START_TS)

    @property
    def value(self) -> int:
        return self.timestamp << 22 | self.instance << 12 | self.seq

    def __int__(self) -> int:
        return self.value


class SnowflakeGenerator:

    def __init__(self, instance: int = 0, seq: int = 0, timestamp: Optional[int] = None):
        current = self.get_new_ts()
        if current - START_TS >= MAX_TS:
            raise OverflowError(f"The maximum current timestamp has been reached,"
                                f"so Snowflake cannot generate more IDs!")

        timestamp = timestamp or current
        if timestamp < 0 or timestamp > current:
            raise ValueError(f"timestamp must not be negative and must be less than {current}!")

        if instance < 0 or instance > MAX_INSTANCE:
            raise ValueError(f"instance must not be negative and must be less than {MAX_INSTANCE}!")

        if seq < 0 or seq > MAX_SEQ:
            raise ValueError(f"seq must not be negative and must be less than {MAX_SEQ}!")

        self._ts = timestamp - START_TS
        self._instance = instance
        self._seq = seq

    @classmethod
    def from_snowflake(cls, sf: SnowflakeID) -> 'SnowflakeGenerator':
        return cls(instance=sf.instance, seq=sf.seq, timestamp=sf.timestamp)

    def __iter__(self):
        return self

    def __next__(self) -> Optional[int]:
        current = self.get_new_ts() - START_TS

        if current >= MAX_TS:
            raise OverflowError(f"The maximum current timestamp has been reached in selected epoch,"
                                f"so Snowflake cannot generate more IDs!")

        if self._ts == current:
            self._seq = (self._seq + 1) & MAX_SEQ
            if self._seq == 0:
                current = self.wait_next_mill() - START_TS  # sequence overrun
        else:
            self._seq = 0

        self._ts = current

        return self._ts << 22 | self._instance << 12 | self._seq

    def wait_next_mill(self):
        mill = self.get_new_ts()
        while mill <= self._ts:
            mill = self.get_new_ts()
        return mill

    @staticmethod
    def get_new_ts():
        return int(time() * 1000)


if __name__ == '__main__':
    import sys
    sys.path.append("../parallel")
    from result_thread import run_threaded_pending, MultiThreadManager

    # Unique Checking
    sf_gen = SnowflakeGenerator(instance=0, seq=0)
    # Get 10 ID generated by Snowflake algorithm in 10 different threads
    manager = MultiThreadManager()
    [manager.add_thread(run_threaded_pending(next, sf_gen)) for i in range(100)]
    manager.start_all()
    # Wait and print output
    all_sf_id = manager.wait_output()
    [print(res) for res in sorted(all_sf_id)]
    # Validate
    assert len(all_sf_id) == len(set(all_sf_id))
    assert all(isinstance(n, int) and len(str(n)) == len(str(all_sf_id[0])) for n in all_sf_id)
    print('-'*80)

    # Reconstruct (or multiple instance)
    new_sf_id = next(sf_gen)
    print(new_sf_id)
    snowflake_ins = SnowflakeID.parse(new_sf_id)
    snowflake_generator = SnowflakeGenerator.from_snowflake(snowflake_ins)
    next_sf_id = next(snowflake_generator)
    print(next_sf_id)  # notes: likely equal to new_sf_id
